
use strict;
use warnings;
use diagnostics;

my $argc = @ARGV;          # get the number of arguments

my ($line,@array,$funcSig, $returnType,@argsName,@argsType,@argsPointer,$rest,$funcName,@args,$arg,$i,@tmp,$resourceContent);
my ($resourceParamType,$resourceReturnType,$parameterLine,$allParameters,$functions,$parameter,$allFunctions,$argNumber,$funcIndex,$allCaseLines);
my ($registerFunctionBodyContent,$caseLine,$allCppParameters, $allFunctionSkeletonsi, $cppParamType,$functionSkeleton,$allFunctionSkeletons);
my ($cppResultType,$allhfileFuncSig,$hfileFuncSig,$hfileSkeleton);

if($argc < 1){
	print "Too less arguments";
	exit 1;
}

system("ctags","--totals=yes", "--c-kinds=+px-t",$ARGV[0] );

open(IN,"<tags") or die "can not open file ctags";


our $resourceFileTemplate = <<EOF;
// autogenerated by create-igor-xop-files.pl from $ARGV[0]
1100 XOPF							// Describes functions added by XOP to IGOR.
BEGIN
	%%functionDefinitions%%
	0,								// NOTE: 0 required to terminate the resource.
END

EOF

our $resourceFileFunctionDefinition= <<EOF;
	// %%funcSig%%
	"%%funcName%%\\0",
	F_UTIL | F_EXTERNAL,			// Function category,
	%%returnType%%,				// Return value type.
%%parameterLine%%	0,

EOF

our $resourceFileParameterLine = "		%%argType%%,			// parameter %%argNumber%%";

our $registerFunctionTemplate= <<EOF;
static long RegisterFunction()
{
	/*	NOTE:
		Some XOPs should return a result of NIL in response to the FUNCADDRS message.
		See XOP manual "Restrictions on Direct XFUNCs" section.
	*/

	int funcIndex = GetXOPItem(0);		/* which function invoked ? */
	long returnValue = NIL;

	switch (funcIndex) {
%%caseLine%%
	}
	return returnValue;
}
EOF

our $registerFunctionCaseTemplate = <<EOF;
		case %%funcIndex%%:						
			returnValue = (long) %%funcName%%;
			break;
EOF

our $hfileFunctionTemplate = <<EOF;

// autogenerated by create-igor-xop-files.pl from $ARGV[0]

#pragma pack(2)	// All structures passed to Igor are two-byte aligned.
struct %%funcName%%Params{
%%functionParamterLine%%
};
typedef struct %%funcName%%Params %%funcName%%Params;
#pragma pack()

EOF

our $functionBodyTemplate= <<EOF;

// %%funcSig%%
static int %%funcName%%(%%funcName%%Params *p){

	p->result = UNKNOWN_ERROR;

	ASSERT_RETURN_ZERO(pMyData);
	if(!pMyData->resultFileOpen()){
		p->result = NO_FILE_OPEN;
		return 0;
	}

	Vernissage::Session *pSession = pMyData->getSession();
	ASSERT_RETURN_ZERO(pSession);



	p->result = SUCCESS;
	return 0;
}




EOF

$rest="";
$funcName="";
$returnType="";
$resourceContent="";
$funcIndex=0;
$allCaseLines="";
$allhfileFuncSig="";

while($line = <IN>){

	if( not ($line =~ m/^!/) ){ # ignore comments

		@array = split(/\//,$line);
		$funcSig = $array[1];
		$funcSig =~ s/^^\^//;
		$funcSig =~ s/;\$$//;

		print "function signature is $funcSig\n";

		($returnType,$rest) = split(/\ /,$funcSig,2);
		@tmp = split(/([()])/,$rest);

		$funcName = $tmp[0];

		# C standard only allows 31 chars as maximum function name length
		if(length($funcName) > 31){
			print "The functions name $funcName is too long. Only 31 chars are allowed.";
			return 0;
		}

		$rest = $tmp[2];

		print "function name $funcName\n";
		print "function return type $returnType\n";
		print "rest _ $rest _\n";

		undef @args;
		@args = split(/ *, */,$rest);

		$allParameters="";
		$allCppParameters="";
		for($i=0; $i < @args; $i++ ){

			$arg = $args[$i];

			if($arg =~ m/\*/){ # is a pointer
				$argsPointer[$i]=1;
			}
			else{
				$argsPointer[$i]=0;
			}

			# we don't know at which position (at the type, between spaces or in front of the variable name) the pointer is so we delete it now and add it afterwards in front of the variable
			$arg =~ s/\*//;

			($argsType[$i],$argsName[$i]) = split(/ +/,$arg,2);

			print "type: $argsType[$i], name: $argsName[$i], pointer: $argsPointer[$i]\n";

			# generate resource file parameter lines

			$resourceParamType = &convertParameterTypeForResourceFile($argsType[$i],$argsPointer[$i]);
			$argNumber = $i+1;

			$parameter = $resourceFileParameterLine;
			$parameter =~ s/%%argType%%/$resourceParamType/g;
			$parameter =~ s/%%argNumber%%/$argNumber/g;
			$allParameters .= "$parameter\n";

			# generate cpp file parameter lines

			$cppParamType = &convertParameterTypeForCPPFile($argsType[$i],$argsPointer[$i]);

			$allCppParameters = "\t$cppParamType$argsName[$i];\n" . $allCppParameters;
		}

		# resource file

		$resourceReturnType = &convertParameterTypeForResourceFile($returnType,0);

		$functions = $resourceFileFunctionDefinition;
		$functions =~ s/%%funcSig%%/$funcSig/g;
		$functions =~ s/%%funcName%%/$funcName/g;
		$functions =~ s/%%parameterLine%%/$allParameters/g;
		$functions =~ s/%%returnType%%/$resourceReturnType/g;

		$allFunctions .= $functions; 

		print "\n\n";

		
		# cpp files

		$cppResultType = &convertParameterTypeForCPPFile($returnType,0);
		$functionSkeleton = $functionBodyTemplate;
		$functionSkeleton =~ s/%%funcName%%/$funcName/g;
		$functionSkeleton =~ s/%%funcSig%%/$funcSig/g;
		$allFunctionSkeletons .= $functionSkeleton;

		$caseLine = $registerFunctionCaseTemplate;
		$caseLine =~ s/%%funcIndex%%/$funcIndex/g;
		$caseLine =~ s/%%funcName%%/$funcName/g;

		$allCaseLines .= $caseLine;
		$funcIndex++;

		# h file
		$allCppParameters .= "\t$cppResultType" . "result;";
		$hfileSkeleton = $hfileFunctionTemplate;
		$hfileSkeleton =~ s/%%functionParamterLine%%/$allCppParameters/g;
		$hfileSkeleton =~ s/%%funcName%%/$funcName/g;

		$hfileFuncSig = "static int $funcName($funcName" . "Params *p);\n";
		$allhfileFuncSig .= $hfileSkeleton;
		$allhfileFuncSig .= $hfileFuncSig;
	}
}
	close(IN);

	open(OUT,">resourceFile.rc") or die "can not open resource file";

	$resourceContent = $resourceFileTemplate;
	$resourceContent =~ s/%%functionDefinitions%%/$allFunctions/;

	print OUT $resourceContent;
	close(OUT);
	
	open(OUT,">functionBodys.cpp") or die "can not open file";

	$registerFunctionBodyContent = $registerFunctionTemplate;
	$registerFunctionBodyContent =~ s/%%caseLine%%/$allCaseLines/;
	
	print OUT "\n\n";
	print OUT $allFunctionSkeletons;
	print OUT "\n\n";

	print OUT $registerFunctionBodyContent;

	close(OUT);

	open(OUT,">functionBodys.h") or die  "can not open file";

	print OUT "\n\n";
	print OUT $allhfileFuncSig;
	print OUT "\n\n";

	close(OUT);

sub convertParameterTypeForResourceFile{

	my ($type,$pointer) = @_;

	my (%types, $resourceType);

	$types{"variable"} = "NT_FP64";
	$types{"string"}   = "HSTRING_TYPE";
	$types{"TEXTWAVE"} = "WAVE_TYPE";
	$types{"FP64WAVE"} = "WAVE_TYPE";

	$resourceType = $types{$type};

	if($pointer == 1 ){
		$resourceType = "FV_REF_TYPE | $resourceType";
	}
	return $resourceType;
		
}

sub convertParameterTypeForCPPFile{

	my ($type,$pointer)= @_;

	my (%types, $CType);

	$types{"variable"} = "double";
	$types{"string"}   = "Handle";
	$types{"TEXTWAVE"} = "waveHndl";
	$types{"FP64WAVE"} = "waveHndl";

	$CType = $types{$type};

	if($pointer == 1 ){
		$CType = "$CType \*";
	}
	else{
		$CType = "$CType  ";
	}
	return $CType;

}

